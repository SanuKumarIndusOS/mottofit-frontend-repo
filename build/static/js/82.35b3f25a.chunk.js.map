{"version":3,"sources":["action/messagingAct.js","helpers/Messaging.js"],"names":["updatePersonTyping","payload","dispatch","getState","messagingReducer","typingMembers","currentChannelMembers","type","identity","participant","state","tempMembers","currentChatItemOwner","filter","userIdenity","currentPerson","userName","includes","MessagingActionType","UPDATE_MESSAGING_DETAILS","person","resetChannelDetails","RESET_CHANNEL_DETAILS","updateMessagingDetails","updateGlobalMessagingDetails","message","currentMesasgedChannelId","channel","sid","currentMesasge","body","currentMesasgeAuthor","author","individualMessages","socialMessages","adminMessages","tempIndividualClient","tempSocialGroup","tempAdminList","handleChannelMessage","allMessages","sort","channel1","channel2","Date","date_updated","messageLeftDOMs","document","getElementsByClassName","forEach","dom","scrollTo","initClientDispatch","callback","UPDATE_CLIENT_INSTANCE","ChatClientInstance","channelData","tempChannelData","map","data","CurrentChannelData","channelId","toISOString","Chat","require","TwilioMessaging","handler","initClient","a","getToken","token","Client","create","client","INITIALIZE_CLIENT","initClientListeners","removeAllListeners","on","globalMessage","onParticipantStartTyping","onParticipantEndedTyping","log","updateToken","joinChannelByID","uniqueChannelId","Promise","resolve","reject","unSubscribeChannel","alert","isLoading","getChannelByUniqueName","joinChannel","onChanelJoined","activeChannel","onMessagedAdded","member","onMemberJoined","onMemberLeft","UPDATE_CHANNEL_DETAILS","channelState","status","join","getMessages","messages","tempMessage","items","activeChannelMessages","console","UPDATE_MESSAGE_DETAILS","getIdentityToken","twilioApi","id","localStorage","getItem","api","then","chatToken","catch","err","Toast","this","callbackApi","clientData"],"mappings":"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","file":"static/js/82.35b3f25a.chunk.js","sourcesContent":["import { MessagingActionType } from \"../service/actionType\";\r\nimport ChatClientInstance from \"../helpers/Messaging\";\r\n\r\nexport const updatePersonTyping = (payload) => (dispatch, getState) => {\r\n  const { typingMembers, currentChannelMembers } = getState().messagingReducer;\r\n  const { type, participant } = payload;\r\n  let { identity } = participant.state;\r\n  let tempMembers = typingMembers;\r\n\r\n  const currentChatItemOwner =\r\n    currentChannelMembers.filter(\r\n      ({ userIdenity }) => userIdenity === identity\r\n    )[0] || {};\r\n\r\n  let currentPerson = currentChatItemOwner?.userName || identity;\r\n\r\n  if (type === \"typingStarted\") {\r\n    // console.log(typingMembers, identity);\r\n\r\n    if (!typingMembers.includes(currentPerson)) {\r\n      tempMembers = [...typingMembers, currentPerson];\r\n\r\n      dispatch({\r\n        type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n        payload: { typingMembers: [...tempMembers] },\r\n      });\r\n    }\r\n  } else if (type === \"typingEnded\") {\r\n    // console.log(typingMembers, currentPerson);\r\n    if (typingMembers.includes(currentPerson)) {\r\n      tempMembers = [...typingMembers].filter(\r\n        (person) => person !== currentPerson\r\n      );\r\n      dispatch({\r\n        type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n        payload: { typingMembers: [...tempMembers] },\r\n      });\r\n    }\r\n  }\r\n};\r\n\r\nexport const resetChannelDetails = () => (dispatch) => {\r\n  dispatch({\r\n    type: MessagingActionType.RESET_CHANNEL_DETAILS,\r\n  });\r\n};\r\n\r\nexport const updateMessagingDetails = (payload) => (dispatch) => {\r\n  dispatch({\r\n    type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n    payload,\r\n  });\r\n};\r\n\r\nexport const updateGlobalMessagingDetails = (message) => (\r\n  dispatch,\r\n  getState\r\n) => {\r\n  const currentMesasgedChannelId = message?.channel?.sid;\r\n  const currentMesasge = message?.state?.body;\r\n  const currentMesasgeAuthor = message?.state?.author;\r\n  const {\r\n    individualMessages,\r\n    socialMessages,\r\n    adminMessages,\r\n  } = getState().messagingReducer;\r\n\r\n  let tempIndividualClient = [...individualMessages];\r\n  let tempSocialGroup = [...socialMessages];\r\n  let tempAdminList = [...adminMessages];\r\n  const currentIndividualChannel = handleChannelMessage(\r\n    tempIndividualClient,\r\n    currentMesasgedChannelId,\r\n    currentMesasge,\r\n    currentMesasgeAuthor\r\n  );\r\n  const currentSocialChannel = handleChannelMessage(\r\n    tempSocialGroup,\r\n    currentMesasgedChannelId,\r\n    currentMesasge,\r\n    currentMesasgeAuthor\r\n  );\r\n  const currentAdminChannel = handleChannelMessage(\r\n    tempAdminList,\r\n    currentMesasgedChannelId,\r\n    currentMesasge,\r\n    currentMesasgeAuthor\r\n  );\r\n\r\n  let currentAllChannel = [\r\n    ...individualMessages,\r\n    ...socialMessages,\r\n    ...adminMessages,\r\n  ].sort((channel1, channel2) => {\r\n    return (\r\n      new Date(channel2?.message?.date_updated || 1950) -\r\n      new Date(channel1?.message?.date_updated || 1950)\r\n    );\r\n  });\r\n\r\n  let payload = {\r\n    individualMessages: currentIndividualChannel,\r\n    socialMessages: currentSocialChannel,\r\n    adminMessages: currentAdminChannel,\r\n    allMessages: currentAllChannel,\r\n  };\r\n\r\n  let messageLeftDOMs = document.getElementsByClassName(\"message_left\");\r\n  [...messageLeftDOMs]?.forEach((dom) => dom?.scrollTo(0, 0));\r\n  dispatch({\r\n    type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n    payload,\r\n  });\r\n};\r\n\r\nexport const initClientDispatch = (callback) => (dispatch, getState) => {\r\n  dispatch({\r\n    type: MessagingActionType.UPDATE_CLIENT_INSTANCE,\r\n    payload: new ChatClientInstance(dispatch, getState, callback),\r\n  });\r\n};\r\n\r\nconst handleChannelMessage = (\r\n  channelData,\r\n  currentMesasgedChannelId,\r\n  currentMesasge,\r\n  author\r\n) => {\r\n  let tempChannelData = [...channelData].map((data) => {\r\n    let CurrentChannelData = { ...data };\r\n\r\n    if (data?.channelId === currentMesasgedChannelId) {\r\n      CurrentChannelData[\"message\"][\"body\"] = currentMesasge;\r\n      CurrentChannelData[\"message\"][\"date_updated\"] = new Date().toISOString();\r\n      CurrentChannelData[\"message\"][\"from\"] = author;\r\n    }\r\n\r\n    return { ...CurrentChannelData };\r\n  });\r\n\r\n  // console.log(tempChannelData, channelData);\r\n\r\n  tempChannelData = tempChannelData.sort((channel1, channel2) => {\r\n    return (\r\n      new Date(channel2?.message?.date_updated || 1950) -\r\n      new Date(channel1?.message?.date_updated || 1950)\r\n    );\r\n  });\r\n\r\n  return [...tempChannelData];\r\n};\r\n","// import config from \"../../config\";\r\n\r\nimport { MessagingActionType } from \"../service/actionType\";\r\nimport { twilioApi } from \"../service/apiVariables\";\r\nimport { api } from \"../service/api\";\r\nimport { Toast } from \"../service/toast\";\r\nimport {\r\n  updatePersonTyping,\r\n  resetChannelDetails,\r\n  updateGlobalMessagingDetails,\r\n} from \"../action/messagingAct\";\r\n\r\nconst Chat = require(\"twilio-chat\");\r\n\r\nexport default class TwilioMessaging {\r\n  constructor(handler, getState, callback) {\r\n    this.getState = getState;\r\n\r\n    this.handler = handler;\r\n\r\n    this.activeChannel = null;\r\n\r\n    this.client = null;\r\n\r\n    this.callbackApi = callback;\r\n\r\n    this.initClient();\r\n  }\r\n\r\n  initClient = async () => {\r\n    const token = await this.getToken();\r\n\r\n    const client = await Chat.Client.create(token);\r\n\r\n    this.client = client;\r\n\r\n    this.handler({\r\n      type: MessagingActionType.INITIALIZE_CLIENT,\r\n      payload: client,\r\n    });\r\n\r\n    this.initClientListeners(client);\r\n  };\r\n\r\n  initClientListeners = (client) => {\r\n    // REMOVE ALL THE EXISTING LISTENERS\r\n    client.removeAllListeners();\r\n\r\n    // client.on(\"channelJoined\", async (channel) => {\r\n    //   // getting list of all messages since this is an existing channel\r\n    //   console.log(channel);\r\n\r\n    //   await this.onChanelJoined(channel);\r\n    // });\r\n\r\n    // LISTEN FOR GLOBAL MESSAGES\r\n\r\n    client.on(\"messageAdded\", async (message) => {\r\n      this.globalMessage(message);\r\n    });\r\n\r\n    // LISTEN FOR PERSON WHOSE ARE TYPING\r\n    client.on(\"typingStarted\", (participant) => {\r\n      this.onParticipantStartTyping(participant);\r\n    });\r\n\r\n    // LISTEN FOR PERSON WHOM HAVE STOP TYPING\r\n    client.on(\"typingEnded\", (participant) => {\r\n      this.onParticipantEndedTyping(participant);\r\n    });\r\n\r\n    //LISTEN AND UPDATE IF TOKEN IS ABOUT TO EXPIRE\r\n\r\n    client.on(\"tokenAboutToExpire\", async () => {\r\n      this.log(\"token is about to expire\");\r\n      const token = await this.getToken();\r\n      client.updateToken(token);\r\n    });\r\n\r\n    // LISTEN IF ALREADY TOKEN HAS EXPIRED\r\n\r\n    client.on(\"tokenExpired\", async () => {\r\n      this.log(\"token is about to expire\");\r\n      const token = await this.getToken();\r\n      client.updateToken(token);\r\n    });\r\n  };\r\n\r\n  globalMessage = (message) => {\r\n    updateGlobalMessagingDetails(message)(this.handler, this.getState);\r\n  };\r\n\r\n  joinChannelByID = async (uniqueChannelId) => {\r\n    return new Promise(async (resolve, reject) => {\r\n      try {\r\n        this.unSubscribeChannel();\r\n        if (!this.client) return alert(\"Twilio loading\");\r\n\r\n        this.handler({\r\n          type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n          payload: { isLoading: true },\r\n        });\r\n\r\n        this.log(`Attempting to join ${uniqueChannelId} channel`);\r\n\r\n        const channel = await this.client.getChannelByUniqueName(\r\n          uniqueChannelId\r\n        );\r\n        await this.joinChannel(channel);\r\n\r\n        await this.onChanelJoined(channel);\r\n\r\n        this.log(`Channel joined`);\r\n\r\n        this.activeChannel = channel;\r\n\r\n        // LISTEN ON CHANNEL MESSAGE ADDED\r\n\r\n        channel.on(\"messageAdded\", async (message) => {\r\n          await this.onMessagedAdded(message);\r\n        });\r\n\r\n        // LISTEN FOR PERSON WHOSE ARE TYPING\r\n        channel.on(\"typingStarted\", (participant) => {\r\n          this.onParticipantStartTyping(participant);\r\n        });\r\n\r\n        // LISTEN FOR PERSON WHOM HAVE STOP TYPING\r\n        channel.on(\"typingEnded\", (participant) => {\r\n          this.onParticipantEndedTyping(participant);\r\n        });\r\n\r\n        // WHEN A MEMBER JOINED\r\n\r\n        channel.on(\"memberJoined\", (member) => {\r\n          this.onMemberJoined(member);\r\n        });\r\n\r\n        // WHEN A MEMBER LEFT\r\n        channel.on(\"memberLeft\", (member) => {\r\n          this.onMemberLeft(member);\r\n        });\r\n\r\n        this.handler({\r\n          type: MessagingActionType.UPDATE_CHANNEL_DETAILS,\r\n          payload: channel,\r\n        });\r\n        resolve(true);\r\n      } catch (err) {\r\n        this.log(`Not able to join the channel`);\r\n        reject(err);\r\n      }\r\n    });\r\n  };\r\n\r\n  joinChannel = async (channel) => {\r\n    if (channel.channelState.status !== \"joined\") {\r\n      await channel.join();\r\n    }\r\n  };\r\n\r\n  // FUNC FIRES WHEN USER JOINED IN A CHANNEL\r\n\r\n  onChanelJoined = async (channel) => {\r\n    const messages = await channel.getMessages();\r\n\r\n    let tempMessage = messages.items || [];\r\n\r\n    this.handler({\r\n      type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n      payload: {\r\n        activeChannelMessages: [...tempMessage],\r\n        isLoading: false,\r\n      },\r\n    });\r\n  };\r\n\r\n  // FUNC FIRES WHEN USER RECIVES MESSAGE\r\n\r\n  onMessagedAdded = (message) => {\r\n    const { channel } = message;\r\n    if (channel.sid !== this.activeChannel.sid) {\r\n      console.log(message, \"msg\", \"diff channel\");\r\n      return {};\r\n    } else {\r\n      return this.handler({\r\n        type: MessagingActionType.UPDATE_MESSAGE_DETAILS,\r\n        payload: message,\r\n      });\r\n    }\r\n  };\r\n\r\n  // WHEN PERSON STARTS TYPING THIS FUNC FIRES\r\n\r\n  onParticipantStartTyping = (participant) => {\r\n    let payload = {\r\n      type: \"typingStarted\",\r\n      participant,\r\n    };\r\n    updatePersonTyping(payload)(this.handler, this.getState);\r\n  };\r\n\r\n  // WHEN PERSON STOPS TYPING THIS FUNC FIRES\r\n\r\n  onParticipantEndedTyping = (participant) => {\r\n    let payload = {\r\n      type: \"typingEnded\",\r\n      participant,\r\n    };\r\n    updatePersonTyping(payload)(this.handler, this.getState);\r\n  };\r\n\r\n  // WHEN NEW PERSON JOINS THE ROOM THIS FUNC FIRES\r\n\r\n  onMemberJoined = (member) => {\r\n    const { state } = member;\r\n\r\n    const { identity } = state;\r\n\r\n    this.log(`${identity} has joined the chat`);\r\n\r\n    return this.handler({\r\n      type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n      payload: {\r\n        status: `${identity} has joined the chat`,\r\n      },\r\n    });\r\n  };\r\n\r\n  // WHEN A PERSON LEFT THE ROOM THIS FUNC FIRES\r\n\r\n  onMemberLeft = (member) => {\r\n    const { state } = member;\r\n\r\n    const { identity } = state;\r\n\r\n    this.log(`${identity} has left the chat`);\r\n\r\n    return this.handler({\r\n      type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n      payload: {\r\n        status: `${identity} has left the chat`,\r\n      },\r\n    });\r\n  };\r\n\r\n  getToken = () => {\r\n    const { getIdentityToken } = twilioApi;\r\n\r\n    getIdentityToken.id = localStorage.getItem(\"user-id\");\r\n\r\n    return new Promise((resolve, reject) => {\r\n      api({ ...getIdentityToken })\r\n        .then(({ chatToken }) => {\r\n          //   console.log(chatToken);\r\n          resolve(chatToken);\r\n        })\r\n        .catch((err) => {\r\n          Toast({ type: \"error\", message: err.message || \"Error\" });\r\n          reject(err);\r\n        });\r\n    });\r\n  };\r\n\r\n  // REMOVE THE LISTENERS FROM THE ACTIVE CHANNEL\r\n\r\n  unSubscribeChannel() {\r\n    if (this.activeChannel) {\r\n      this.activeChannel.removeAllListeners();\r\n      this.activeChannel = null;\r\n      this.log(\"Un subscribed from the channel\");\r\n    }\r\n    resetChannelDetails()(this.handler);\r\n  }\r\n\r\n  // REMOVE CHAT CLIENT\r\n\r\n  removeChatClient() {\r\n    if (this.client) {\r\n      this.client.removeAllListeners();\r\n      this.client = null;\r\n      this.handler({\r\n        type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n        payload: { clientData: null },\r\n      });\r\n      this.unSubscribeChannel();\r\n      this.log(\"chat client removed\");\r\n    }\r\n  }\r\n\r\n  log(message) {\r\n    console.log(`---------${message}------`);\r\n  }\r\n}\r\n"],"sourceRoot":""}