{"version":3,"sources":["action/messagingAct.js","helpers/Messaging.js"],"names":["updatePersonTyping","payload","dispatch","getState","messagingReducer","typingMembers","currentChannelMembers","type","identity","participant","state","tempMembers","currentChatItemOwner","filter","userIdenity","currentPerson","userName","includes","MessagingActionType","UPDATE_MESSAGING_DETAILS","person","resetChannelDetails","RESET_CHANNEL_DETAILS","updateMessagingDetails","initClientDispatch","callback","UPDATE_CLIENT_INSTANCE","ChatClientInstance","Chat","require","TwilioMessaging","handler","initClient","a","getToken","token","Client","create","client","INITIALIZE_CLIENT","initClientListeners","removeAllListeners","on","message","globalMessage","onParticipantStartTyping","onParticipantEndedTyping","log","updateToken","callbackApi","joinChannelByID","uniqueChannelId","Promise","resolve","reject","unSubscribeChannel","alert","isLoading","getChannelByUniqueName","channel","joinChannel","onChanelJoined","activeChannel","onMessagedAdded","member","onMemberJoined","onMemberLeft","UPDATE_CHANNEL_DETAILS","channelState","status","join","getMessages","messages","tempMessage","items","activeChannelMessages","sid","console","UPDATE_MESSAGE_DETAILS","getIdentityToken","twilioApi","id","localStorage","getItem","api","then","chatToken","catch","err","Toast","this","clientData"],"mappings":"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","file":"static/js/82.ef662ede.chunk.js","sourcesContent":["import { MessagingActionType } from \"../service/actionType\";\r\nimport ChatClientInstance from \"../helpers/Messaging\";\r\n\r\nexport const updatePersonTyping = (payload) => (dispatch, getState) => {\r\n  const { typingMembers, currentChannelMembers } = getState().messagingReducer;\r\n  const { type, participant } = payload;\r\n  let { identity } = participant.state;\r\n  let tempMembers = typingMembers;\r\n\r\n  const currentChatItemOwner =\r\n    currentChannelMembers.filter(\r\n      ({ userIdenity }) => userIdenity === identity\r\n    )[0] || {};\r\n\r\n  let currentPerson = currentChatItemOwner?.userName || identity;\r\n\r\n  if (type === \"typingStarted\") {\r\n    // console.log(typingMembers, identity);\r\n\r\n    if (!typingMembers.includes(currentPerson)) {\r\n      tempMembers = [...typingMembers, currentPerson];\r\n\r\n      dispatch({\r\n        type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n        payload: { typingMembers: [...tempMembers] },\r\n      });\r\n    }\r\n  } else if (type === \"typingEnded\") {\r\n    // console.log(typingMembers, currentPerson);\r\n    if (typingMembers.includes(currentPerson)) {\r\n      tempMembers = [...typingMembers].filter(\r\n        (person) => person !== currentPerson\r\n      );\r\n      dispatch({\r\n        type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n        payload: { typingMembers: [...tempMembers] },\r\n      });\r\n    }\r\n  }\r\n};\r\n\r\nexport const resetChannelDetails = () => (dispatch) => {\r\n  dispatch({\r\n    type: MessagingActionType.RESET_CHANNEL_DETAILS,\r\n  });\r\n};\r\n\r\nexport const updateMessagingDetails = (payload) => (dispatch) => {\r\n  dispatch({\r\n    type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n    payload,\r\n  });\r\n};\r\n\r\nexport const initClientDispatch = (callback) => (dispatch, getState) => {\r\n  dispatch({\r\n    type: MessagingActionType.UPDATE_CLIENT_INSTANCE,\r\n    payload: new ChatClientInstance(dispatch, getState, callback),\r\n  });\r\n};\r\n","// import config from \"../../config\";\r\n\r\nimport { MessagingActionType } from \"../service/actionType\";\r\nimport { twilioApi } from \"../service/apiVariables\";\r\nimport { api } from \"../service/api\";\r\nimport { Toast } from \"../service/toast\";\r\nimport {\r\n  updatePersonTyping,\r\n  resetChannelDetails,\r\n} from \"../action/messagingAct\";\r\n\r\nconst Chat = require(\"twilio-chat\");\r\n\r\nexport default class TwilioMessaging {\r\n  constructor(handler, getState, callback) {\r\n    this.getState = getState;\r\n\r\n    this.handler = handler;\r\n\r\n    this.activeChannel = null;\r\n\r\n    this.client = null;\r\n\r\n    this.callbackApi = callback;\r\n\r\n    this.initClient();\r\n  }\r\n\r\n  initClient = async () => {\r\n    const token = await this.getToken();\r\n\r\n    const client = await Chat.Client.create(token);\r\n\r\n    this.client = client;\r\n\r\n    this.handler({\r\n      type: MessagingActionType.INITIALIZE_CLIENT,\r\n      payload: client,\r\n    });\r\n\r\n    this.initClientListeners(client);\r\n  };\r\n\r\n  initClientListeners = (client) => {\r\n    // REMOVE ALL THE EXISTING LISTENERS\r\n    client.removeAllListeners();\r\n\r\n    // client.on(\"channelJoined\", async (channel) => {\r\n    //   // getting list of all messages since this is an existing channel\r\n    //   console.log(channel);\r\n\r\n    //   await this.onChanelJoined(channel);\r\n    // });\r\n\r\n    // LISTEN FOR GLOBAL MESSAGES\r\n\r\n    client.on(\"messageAdded\", async (message) => {\r\n      this.globalMessage(message);\r\n    });\r\n\r\n    // LISTEN FOR PERSON WHOSE ARE TYPING\r\n    client.on(\"typingStarted\", (participant) => {\r\n      this.onParticipantStartTyping(participant);\r\n    });\r\n\r\n    // LISTEN FOR PERSON WHOM HAVE STOP TYPING\r\n    client.on(\"typingEnded\", (participant) => {\r\n      this.onParticipantEndedTyping(participant);\r\n    });\r\n\r\n    //LISTEN AND UPDATE IF TOKEN IS ABOUT TO EXPIRE\r\n\r\n    client.on(\"tokenAboutToExpire\", async () => {\r\n      this.log(\"token is about to expire\");\r\n      const token = await this.getToken();\r\n      client.updateToken(token);\r\n    });\r\n\r\n    // LISTEN IF ALREADY TOKEN HAS EXPIRED\r\n\r\n    client.on(\"tokenExpired\", async () => {\r\n      this.log(\"token is about to expire\");\r\n      const token = await this.getToken();\r\n      client.updateToken(token);\r\n    });\r\n  };\r\n\r\n  globalMessage = (message) => {\r\n    // console.log(message.channel, this.activeChannel);\r\n\r\n    // if (message.channel.sid !== this.activeChannel.sid) {\r\n    //   console.log(message);\r\n    this.callbackApi && this.callbackApi();\r\n    // }\r\n  };\r\n\r\n  joinChannelByID = async (uniqueChannelId) => {\r\n    return new Promise(async (resolve, reject) => {\r\n      try {\r\n        this.unSubscribeChannel();\r\n        if (!this.client) return alert(\"Twilio loading\");\r\n\r\n        this.handler({\r\n          type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n          payload: { isLoading: true },\r\n        });\r\n\r\n        this.log(`Attempting to join ${uniqueChannelId} channel`);\r\n\r\n        const channel = await this.client.getChannelByUniqueName(\r\n          uniqueChannelId\r\n        );\r\n        await this.joinChannel(channel);\r\n\r\n        await this.onChanelJoined(channel);\r\n\r\n        this.log(`Channel joined`);\r\n\r\n        this.activeChannel = channel;\r\n\r\n        // LISTEN ON CHANNEL MESSAGE ADDED\r\n\r\n        channel.on(\"messageAdded\", async (message) => {\r\n          await this.onMessagedAdded(message);\r\n        });\r\n\r\n        // LISTEN FOR PERSON WHOSE ARE TYPING\r\n        channel.on(\"typingStarted\", (participant) => {\r\n          this.onParticipantStartTyping(participant);\r\n        });\r\n\r\n        // LISTEN FOR PERSON WHOM HAVE STOP TYPING\r\n        channel.on(\"typingEnded\", (participant) => {\r\n          this.onParticipantEndedTyping(participant);\r\n        });\r\n\r\n        // WHEN A MEMBER JOINED\r\n\r\n        channel.on(\"memberJoined\", (member) => {\r\n          this.onMemberJoined(member);\r\n        });\r\n\r\n        // WHEN A MEMBER LEFT\r\n        channel.on(\"memberLeft\", (member) => {\r\n          this.onMemberLeft(member);\r\n        });\r\n\r\n        this.handler({\r\n          type: MessagingActionType.UPDATE_CHANNEL_DETAILS,\r\n          payload: channel,\r\n        });\r\n        resolve(true);\r\n      } catch (err) {\r\n        this.log(`Not able to join the channel`);\r\n        reject(err);\r\n      }\r\n    });\r\n  };\r\n\r\n  joinChannel = async (channel) => {\r\n    if (channel.channelState.status !== \"joined\") {\r\n      await channel.join();\r\n    }\r\n  };\r\n\r\n  // FUNC FIRES WHEN USER JOINED IN A CHANNEL\r\n\r\n  onChanelJoined = async (channel) => {\r\n    const messages = await channel.getMessages();\r\n\r\n    let tempMessage = messages.items || [];\r\n\r\n    this.handler({\r\n      type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n      payload: {\r\n        activeChannelMessages: [...tempMessage],\r\n        isLoading: false,\r\n      },\r\n    });\r\n  };\r\n\r\n  // FUNC FIRES WHEN USER RECIVES MESSAGE\r\n\r\n  onMessagedAdded = (message) => {\r\n    const { channel } = message;\r\n    if (channel.sid !== this.activeChannel.sid) {\r\n      console.log(message, \"msg\", \"diff channel\");\r\n      return {};\r\n    } else {\r\n      return this.handler({\r\n        type: MessagingActionType.UPDATE_MESSAGE_DETAILS,\r\n        payload: message,\r\n      });\r\n    }\r\n  };\r\n\r\n  // WHEN PERSON STARTS TYPING THIS FUNC FIRES\r\n\r\n  onParticipantStartTyping = (participant) => {\r\n    let payload = {\r\n      type: \"typingStarted\",\r\n      participant,\r\n    };\r\n    updatePersonTyping(payload)(this.handler, this.getState);\r\n  };\r\n\r\n  // WHEN PERSON STOPS TYPING THIS FUNC FIRES\r\n\r\n  onParticipantEndedTyping = (participant) => {\r\n    let payload = {\r\n      type: \"typingEnded\",\r\n      participant,\r\n    };\r\n    updatePersonTyping(payload)(this.handler, this.getState);\r\n  };\r\n\r\n  // WHEN NEW PERSON JOINS THE ROOM THIS FUNC FIRES\r\n\r\n  onMemberJoined = (member) => {\r\n    const { state } = member;\r\n\r\n    const { identity } = state;\r\n\r\n    this.log(`${identity} has joined the chat`);\r\n\r\n    return this.handler({\r\n      type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n      payload: {\r\n        status: `${identity} has joined the chat`,\r\n      },\r\n    });\r\n  };\r\n\r\n  // WHEN A PERSON LEFT THE ROOM THIS FUNC FIRES\r\n\r\n  onMemberLeft = (member) => {\r\n    const { state } = member;\r\n\r\n    const { identity } = state;\r\n\r\n    this.log(`${identity} has left the chat`);\r\n\r\n    return this.handler({\r\n      type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n      payload: {\r\n        status: `${identity} has left the chat`,\r\n      },\r\n    });\r\n  };\r\n\r\n  getToken = () => {\r\n    const { getIdentityToken } = twilioApi;\r\n\r\n    getIdentityToken.id = localStorage.getItem(\"user-id\");\r\n\r\n    return new Promise((resolve, reject) => {\r\n      api({ ...getIdentityToken })\r\n        .then(({ chatToken }) => {\r\n          //   console.log(chatToken);\r\n          resolve(chatToken);\r\n        })\r\n        .catch((err) => {\r\n          Toast({ type: \"error\", message: err.message || \"Error\" });\r\n          reject(err);\r\n        });\r\n    });\r\n  };\r\n\r\n  // REMOVE THE LISTENERS FROM THE ACTIVE CHANNEL\r\n\r\n  unSubscribeChannel() {\r\n    if (this.activeChannel) {\r\n      this.activeChannel.removeAllListeners();\r\n      this.activeChannel = null;\r\n      this.log(\"Un subscribed from the channel\");\r\n    }\r\n    resetChannelDetails()(this.handler);\r\n  }\r\n\r\n  // REMOVE CHAT CLIENT\r\n\r\n  removeChatClient() {\r\n    if (this.client) {\r\n      this.client.removeAllListeners();\r\n      this.client = null;\r\n      this.handler({\r\n        type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n        payload: { clientData: null },\r\n      });\r\n      this.unSubscribeChannel();\r\n      this.log(\"chat client removed\");\r\n    }\r\n  }\r\n\r\n  log(message) {\r\n    console.log(`---------${message}------`);\r\n  }\r\n}\r\n"],"sourceRoot":""}