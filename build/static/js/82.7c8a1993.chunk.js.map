{"version":3,"sources":["action/messagingAct.js","helpers/Messaging.js"],"names":["updatePersonTyping","payload","dispatch","getState","messagingReducer","typingMembers","currentChannelMembers","type","identity","participant","state","tempMembers","currentChatItemOwner","filter","userIdenity","currentPerson","userName","includes","MessagingActionType","UPDATE_MESSAGING_DETAILS","person","resetChannelDetails","RESET_CHANNEL_DETAILS","updateMessagingDetails","initClientDispatch","UPDATE_CLIENT_INSTANCE","ChatClientInstance","Chat","require","TwilioMessaging","handler","initClient","a","getToken","token","Client","create","client","INITIALIZE_CLIENT","initClientListeners","removeAllListeners","on","onParticipantStartTyping","onParticipantEndedTyping","log","updateToken","joinChannelByID","uniqueChannelId","Promise","resolve","reject","unSubscribeChannel","alert","isLoading","getChannelByUniqueName","channel","joinChannel","onChanelJoined","activeChannel","message","onMessagedAdded","member","onMemberJoined","onMemberLeft","UPDATE_CHANNEL_DETAILS","channelState","status","join","getMessages","messages","tempMessage","items","activeChannelMessages","sid","console","UPDATE_MESSAGE_DETAILS","getIdentityToken","twilioApi","id","localStorage","getItem","api","then","chatToken","catch","err","Toast","this","clientData"],"mappings":"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","file":"static/js/82.7c8a1993.chunk.js","sourcesContent":["import { MessagingActionType } from \"../service/actionType\";\r\nimport ChatClientInstance from \"../helpers/Messaging\";\r\n\r\nexport const updatePersonTyping = (payload) => (dispatch, getState) => {\r\n  const { typingMembers, currentChannelMembers } = getState().messagingReducer;\r\n  const { type, participant } = payload;\r\n  let { identity } = participant.state;\r\n  let tempMembers = typingMembers;\r\n\r\n  const currentChatItemOwner =\r\n    currentChannelMembers.filter(\r\n      ({ userIdenity }) => userIdenity === identity\r\n    )[0] || {};\r\n\r\n  let currentPerson = currentChatItemOwner?.userName || identity;\r\n\r\n  if (type === \"typingStarted\") {\r\n    // console.log(typingMembers, identity);\r\n\r\n    if (!typingMembers.includes(currentPerson)) {\r\n      tempMembers = [...typingMembers, currentPerson];\r\n\r\n      dispatch({\r\n        type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n        payload: { typingMembers: [...tempMembers] },\r\n      });\r\n    }\r\n  } else if (type === \"typingEnded\") {\r\n    // console.log(typingMembers, currentPerson);\r\n    if (typingMembers.includes(currentPerson)) {\r\n      tempMembers = [...typingMembers].filter(\r\n        (person) => person !== currentPerson\r\n      );\r\n      dispatch({\r\n        type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n        payload: { typingMembers: [...tempMembers] },\r\n      });\r\n    }\r\n  }\r\n};\r\n\r\nexport const resetChannelDetails = () => (dispatch) => {\r\n  dispatch({\r\n    type: MessagingActionType.RESET_CHANNEL_DETAILS,\r\n  });\r\n};\r\n\r\nexport const updateMessagingDetails = (payload) => (dispatch) => {\r\n  dispatch({\r\n    type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n    payload,\r\n  });\r\n};\r\n\r\nexport const initClientDispatch = () => (dispatch, getState) => {\r\n  dispatch({\r\n    type: MessagingActionType.UPDATE_CLIENT_INSTANCE,\r\n    payload: new ChatClientInstance(dispatch, getState),\r\n  });\r\n};\r\n","// import config from \"../../config\";\r\n\r\nimport { MessagingActionType } from \"../service/actionType\";\r\nimport { twilioApi } from \"../service/apiVariables\";\r\nimport { api } from \"../service/api\";\r\nimport { Toast } from \"../service/toast\";\r\nimport {\r\n  updatePersonTyping,\r\n  resetChannelDetails,\r\n} from \"../action/messagingAct\";\r\n\r\nconst Chat = require(\"twilio-chat\");\r\n\r\nexport default class TwilioMessaging {\r\n  constructor(handler, getState) {\r\n    this.getState = getState;\r\n\r\n    this.handler = handler;\r\n\r\n    this.activeChannel = null;\r\n\r\n    this.client = null;\r\n\r\n    this.initClient();\r\n  }\r\n\r\n  initClient = async () => {\r\n    const token = await this.getToken();\r\n\r\n    const client = await Chat.Client.create(token);\r\n\r\n    this.client = client;\r\n\r\n    this.handler({\r\n      type: MessagingActionType.INITIALIZE_CLIENT,\r\n      payload: client,\r\n    });\r\n\r\n    this.initClientListeners(client);\r\n  };\r\n\r\n  initClientListeners = (client) => {\r\n    // REMOVE ALL THE EXISTING LISTENERS\r\n    client.removeAllListeners();\r\n\r\n    // client.on(\"channelJoined\", async (channel) => {\r\n    //   // getting list of all messages since this is an existing channel\r\n    //   console.log(channel);\r\n\r\n    //   await this.onChanelJoined(channel);\r\n    // });\r\n\r\n    // LISTEN FOR GLOBAL MESSAGES\r\n\r\n    // client.on(\"messageAdded\", async (message) => {\r\n    //   await this.handler(this.onMessagedAdded(message));\r\n    // });\r\n\r\n    // LISTEN FOR PERSON WHOSE ARE TYPING\r\n    client.on(\"typingStarted\", (participant) => {\r\n      this.onParticipantStartTyping(participant);\r\n    });\r\n\r\n    // LISTEN FOR PERSON WHOM HAVE STOP TYPING\r\n    client.on(\"typingEnded\", (participant) => {\r\n      this.onParticipantEndedTyping(participant);\r\n    });\r\n\r\n    //LISTEN AND UPDATE IF TOKEN IS ABOUT TO EXPIRE\r\n\r\n    client.on(\"tokenAboutToExpire\", async () => {\r\n      this.log(\"token is about to expire\");\r\n      const token = await this.getToken();\r\n      client.updateToken(token);\r\n    });\r\n\r\n    // LISTEN IF ALREADY TOKEN HAS EXPIRED\r\n\r\n    client.on(\"tokenExpired\", async () => {\r\n      this.log(\"token is about to expire\");\r\n      const token = await this.getToken();\r\n      client.updateToken(token);\r\n    });\r\n  };\r\n\r\n  joinChannelByID = async (uniqueChannelId) => {\r\n    return new Promise(async (resolve, reject) => {\r\n      try {\r\n        this.unSubscribeChannel();\r\n        if (!this.client) return alert(\"Twilio loading\");\r\n\r\n        this.handler({\r\n          type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n          payload: { isLoading: true },\r\n        });\r\n\r\n        this.log(`Attempting to join ${uniqueChannelId} channel`);\r\n\r\n        const channel = await this.client.getChannelByUniqueName(\r\n          uniqueChannelId\r\n        );\r\n        await this.joinChannel(channel);\r\n\r\n        await this.onChanelJoined(channel);\r\n\r\n        this.log(`Channel joined`);\r\n\r\n        this.activeChannel = channel;\r\n\r\n        // LISTEN ON CHANNEL MESSAGE ADDED\r\n\r\n        channel.on(\"messageAdded\", async (message) => {\r\n          await this.onMessagedAdded(message);\r\n        });\r\n\r\n        // LISTEN FOR PERSON WHOSE ARE TYPING\r\n        channel.on(\"typingStarted\", (participant) => {\r\n          this.onParticipantStartTyping(participant);\r\n        });\r\n\r\n        // LISTEN FOR PERSON WHOM HAVE STOP TYPING\r\n        channel.on(\"typingEnded\", (participant) => {\r\n          this.onParticipantEndedTyping(participant);\r\n        });\r\n\r\n        // WHEN A MEMBER JOINED\r\n\r\n        channel.on(\"memberJoined\", (member) => {\r\n          this.onMemberJoined(member);\r\n        });\r\n\r\n        // WHEN A MEMBER LEFT\r\n        channel.on(\"memberLeft\", (member) => {\r\n          this.onMemberLeft(member);\r\n        });\r\n\r\n        this.handler({\r\n          type: MessagingActionType.UPDATE_CHANNEL_DETAILS,\r\n          payload: channel,\r\n        });\r\n        resolve(true);\r\n      } catch (err) {\r\n        this.log(`Not able to join the channel`);\r\n        reject(err);\r\n      }\r\n    });\r\n  };\r\n\r\n  joinChannel = async (channel) => {\r\n    if (channel.channelState.status !== \"joined\") {\r\n      await channel.join();\r\n    }\r\n  };\r\n\r\n  // FUNC FIRES WHEN USER JOINED IN A CHANNEL\r\n\r\n  onChanelJoined = async (channel) => {\r\n    const messages = await channel.getMessages();\r\n\r\n    let tempMessage = messages.items || [];\r\n\r\n    this.handler({\r\n      type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n      payload: {\r\n        activeChannelMessages: [...tempMessage],\r\n        isLoading: false,\r\n      },\r\n    });\r\n  };\r\n\r\n  // FUNC FIRES WHEN USER RECIVES MESSAGE\r\n\r\n  onMessagedAdded = (message) => {\r\n    const { channel } = message;\r\n    if (channel.sid !== this.activeChannel.sid) {\r\n      console.log(message, \"msg\", \"diff channel\");\r\n      return {};\r\n    } else {\r\n      return this.handler({\r\n        type: MessagingActionType.UPDATE_MESSAGE_DETAILS,\r\n        payload: message,\r\n      });\r\n    }\r\n  };\r\n\r\n  // WHEN PERSON STARTS TYPING THIS FUNC FIRES\r\n\r\n  onParticipantStartTyping = (participant) => {\r\n    let payload = {\r\n      type: \"typingStarted\",\r\n      participant,\r\n    };\r\n    updatePersonTyping(payload)(this.handler, this.getState);\r\n  };\r\n\r\n  // WHEN PERSON STOPS TYPING THIS FUNC FIRES\r\n\r\n  onParticipantEndedTyping = (participant) => {\r\n    let payload = {\r\n      type: \"typingEnded\",\r\n      participant,\r\n    };\r\n    updatePersonTyping(payload)(this.handler, this.getState);\r\n  };\r\n\r\n  // WHEN NEW PERSON JOINS THE ROOM THIS FUNC FIRES\r\n\r\n  onMemberJoined = (member) => {\r\n    const { state } = member;\r\n\r\n    const { identity } = state;\r\n\r\n    this.log(`${identity} has joined the chat`);\r\n\r\n    return this.handler({\r\n      type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n      payload: {\r\n        status: `${identity} has joined the chat`,\r\n      },\r\n    });\r\n  };\r\n\r\n  // WHEN A PERSON LEFT THE ROOM THIS FUNC FIRES\r\n\r\n  onMemberLeft = (member) => {\r\n    const { state } = member;\r\n\r\n    const { identity } = state;\r\n\r\n    this.log(`${identity} has left the chat`);\r\n\r\n    return this.handler({\r\n      type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n      payload: {\r\n        status: `${identity} has left the chat`,\r\n      },\r\n    });\r\n  };\r\n\r\n  getToken = () => {\r\n    const { getIdentityToken } = twilioApi;\r\n\r\n    getIdentityToken.id = localStorage.getItem(\"user-id\");\r\n\r\n    return new Promise((resolve, reject) => {\r\n      api({ ...getIdentityToken })\r\n        .then(({ chatToken }) => {\r\n          //   console.log(chatToken);\r\n          resolve(chatToken);\r\n        })\r\n        .catch((err) => {\r\n          Toast({ type: \"error\", message: err.message || \"Error\" });\r\n          reject(err);\r\n        });\r\n    });\r\n  };\r\n\r\n  // REMOVE THE LISTENERS FROM THE ACTIVE CHANNEL\r\n\r\n  unSubscribeChannel() {\r\n    if (this.activeChannel) {\r\n      this.activeChannel.removeAllListeners();\r\n      this.activeChannel = null;\r\n      this.log(\"Un subscribed from the channel\");\r\n    }\r\n    resetChannelDetails()(this.handler);\r\n  }\r\n\r\n  // REMOVE CHAT CLIENT\r\n\r\n  removeChatClient() {\r\n    if (this.client) {\r\n      this.client.removeAllListeners();\r\n      this.client = null;\r\n      this.handler({\r\n        type: MessagingActionType.UPDATE_MESSAGING_DETAILS,\r\n        payload: { clientData: null },\r\n      });\r\n      this.unSubscribeChannel();\r\n      this.log(\"chat client removed\");\r\n    }\r\n  }\r\n\r\n  log(message) {\r\n    console.log(`---------${message}------`);\r\n  }\r\n}\r\n"],"sourceRoot":""}